"""
Report Generation Service for Ads Monkee

Generates client-friendly PDF reports from analysis data and uploads to GoHighLevel.
"""
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
import json
import io
from pathlib import Path

from sqlalchemy.orm import Session
from reportlab.lib.pagesizes import letter, A4
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak
from reportlab.lib.units import inch
from reportlab.lib.colors import HexColor
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT

from backend.database import SyncSessionLocal
from backend.models.client import Client
from backend.models.analysis import Analysis


class ReportGenerator:
    """Generate client reports from Ads Monkee analysis data."""

    def __init__(self, db: Session):
        self.db = db
        self.styles = getSampleStyleSheet()
        self._setup_custom_styles()

    def _setup_custom_styles(self):
        """Set up custom styles for the report."""
        # Header style
        self.styles.add(ParagraphStyle(
            name='CustomHeader',
            parent=self.styles['Heading1'],
            fontSize=18,
            spaceAfter=20,
            textColor=HexColor('#2E86AB')
        ))

        # Subheader style
        self.styles.add(ParagraphStyle(
            name='CustomSubheader',
            parent=self.styles['Heading2'],
            fontSize=14,
            spaceAfter=15,
            textColor=HexColor('#A23B72')
        ))

        # Body text style
        self.styles.add(ParagraphStyle(
            name='CustomBody',
            parent=self.styles['Normal'],
            fontSize=10,
            spaceAfter=10
        ))

    def generate_client_report(self, client_id: int, analysis_run_id: Optional[int] = None) -> bytes:
        """
        Generate a comprehensive client report.

        Args:
            client_id: ID of the client
            analysis_run_id: Specific analysis run to include (optional)

        Returns:
            PDF report as bytes
        """
        # Get client data
        client = self.db.query(Client).filter(Client.id == client_id).first()
        if not client:
            raise ValueError(f"Client {client_id} not found")

        # Get latest analysis if not specified
        if not analysis_run_id:
            analysis = self.db.query(Analysis).filter(
                Analysis.client_id == client_id
            ).order_by(Analysis.created_at.desc()).first()
        else:
            analysis = self.db.query(Analysis).filter(
                Analysis.id == analysis_run_id,
                Analysis.client_id == client_id
            ).first()

        # Use placeholder analysis if none exists (for testing)
        if not analysis:
            print(f"[WARNING] No analysis found for client {client_id}, using placeholder data")
            analysis = type('Analysis', (), {
                'results': '{"recommendations": []}',
                'created_at': datetime.now()
            })()

        # Create PDF buffer
        buffer = io.BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=letter)

        # Build report content
        story = []

        # Title page
        story.extend(self._create_title_page(client, analysis))

        # Executive summary
        story.extend(self._create_executive_summary(client, analysis))

        # Campaign performance
        story.extend(self._create_campaign_performance(client, analysis))

        # Recommendations
        story.extend(self._create_recommendations(client, analysis))

        # Build PDF
        doc.build(story)

        # Return PDF bytes
        buffer.seek(0)
        return buffer.getvalue()

    def _create_title_page(self, client: Client, analysis: Analysis) -> List:
        """Create the title page."""
        story = []

        # Main title
        title = Paragraph(
            f"Digital Advertising Performance Report<br/>{client.name}",
            self.styles['CustomHeader']
        )
        story.append(title)
        story.append(Spacer(1, 0.5 * inch))

        # Report details
        report_date = datetime.now().strftime("%B %d, %Y")
        analysis_period = analysis.created_at.strftime("%B %Y")

        details_text = f"""
        <b>Report Generated:</b> {report_date}<br/>
        <b>Analysis Period:</b> {analysis_period}<br/>
        <b>Report Type:</b> Comprehensive Campaign Analysis<br/>
        <b>Generated by:</b> Ads Monkee AI Platform
        """

        details = Paragraph(details_text, self.styles['CustomBody'])
        story.append(details)
        story.append(PageBreak())

        return story

    def _create_executive_summary(self, client: Client, analysis: Analysis) -> List:
        """Create executive summary section."""
        story = []

        # Section header
        header = Paragraph("Executive Summary", self.styles['CustomSubheader'])
        story.append(header)

        # Parse analysis results
        try:
            results = json.loads(analysis.results) if analysis.results else {}
        except json.JSONDecodeError:
            results = {}

        # Summary text
        summary_text = f"""
        This report provides a comprehensive analysis of your digital advertising campaigns
        managed through the Ads Monkee platform. Our AI-powered analysis has reviewed your
        campaign performance, identified optimization opportunities, and generated actionable
        recommendations to improve your return on advertising spend.

        <b>Key Findings:</b><br/>
        • Campaign performance analyzed across all active advertising channels<br/>
        • AI consensus reached on optimization opportunities<br/>
        • Strategic recommendations for improved performance<br/>
        • Actionable next steps for implementation

        The following sections provide detailed insights and specific recommendations
        tailored to your business objectives and current campaign structure.
        """

        summary = Paragraph(summary_text, self.styles['CustomBody'])
        story.append(summary)
        story.append(Spacer(1, 0.3 * inch))

        return story

    def _create_campaign_performance(self, client: Client, analysis: Analysis) -> List:
        """Create campaign performance section."""
        story = []

        # Section header
        header = Paragraph("Campaign Performance Overview", self.styles['CustomSubheader'])
        story.append(header)

        # Performance metrics table (placeholder for now)
        performance_text = """
        <b>Current Performance Metrics:</b><br/>
        • Total Campaigns: Data loading...<br/>
        • Average Click-Through Rate: Data loading...<br/>
        • Cost Per Conversion: Data loading...<br/>
        • Return on Ad Spend: Data loading...<br/>

        Detailed performance breakdowns and trend analysis will be included
        once the aggregate data processing is complete.
        """

        performance = Paragraph(performance_text, self.styles['CustomBody'])
        story.append(performance)
        story.append(Spacer(1, 0.3 * inch))

        return story

    def _create_recommendations(self, client: Client, analysis: Analysis) -> List:
        """Create recommendations section."""
        story = []

        # Section header
        header = Paragraph("Strategic Recommendations", self.styles['CustomSubheader'])
        story.append(header)

        # Parse recommendations from analysis
        try:
            results = json.loads(analysis.results) if analysis.results else {}
            recommendations = results.get('recommendations', [])
        except (json.JSONDecodeError, KeyError):
            recommendations = []

        if recommendations:
            for i, rec in enumerate(recommendations[:5], 1):  # Show top 5
                rec_text = f"""
                <b>{i}. {rec.get('title', 'Recommendation')}</b><br/>
                {rec.get('description', 'No description available.')}<br/>
                <b>Priority:</b> {rec.get('priority', 'Medium')}<br/>
                <b>Expected Impact:</b> {rec.get('expected_impact', 'TBD')}<br/><br/>
                """
                rec_para = Paragraph(rec_text, self.styles['CustomBody'])
                story.append(rec_para)
        else:
            # Placeholder recommendations
            placeholder_text = """
            <b>Key Recommendations:</b><br/>
            • Review and optimize keyword targeting based on performance data<br/>
            • Consider adjusting bid strategies for better cost efficiency<br/>
            • Monitor quality scores and implement improvements<br/>
            • Evaluate ad copy performance and A/B test variations<br/>
            • Assess geographic performance for optimization opportunities<br/>
            """
            placeholder = Paragraph(placeholder_text, self.styles['CustomBody'])
            story.append(placeholder)

        story.append(Spacer(1, 0.3 * inch))

        # Next steps
        next_steps_header = Paragraph("Next Steps", self.styles['CustomSubheader'])
        story.append(next_steps_header)

        next_steps_text = """
        1. Review this report with your Ads Monkee account manager
        2. Schedule implementation of approved recommendations
        3. Monitor performance changes over the next 30 days
        4. Schedule follow-up analysis in 4-6 weeks

        For questions or to discuss implementation, contact your dedicated
        Ads Monkee support team.
        """

        next_steps = Paragraph(next_steps_text, self.styles['CustomBody'])
        story.append(next_steps)

        return story

    def save_report_to_file(self, client_id: int, report_bytes: bytes, filename: Optional[str] = None) -> str:
        """Save report to temporary file for GHL upload."""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"ads_monkee_report_client_{client_id}_{timestamp}.pdf"

        # Save to .tmp directory
        tmp_dir = Path(".tmp")
        tmp_dir.mkdir(exist_ok=True)

        file_path = tmp_dir / filename
        with open(file_path, 'wb') as f:
            f.write(report_bytes)

        return str(file_path)


def generate_client_report(client_id: int, analysis_id: Optional[int] = None) -> bytes:
    """Generate a client report."""
    db = SyncSessionLocal()
    generator = ReportGenerator(db)
    return generator.generate_client_report(client_id, analysis_id)
